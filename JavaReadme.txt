PS：首先是运行问题，windows的terminal只认识GBK字符，而Java采用的是Unicode编码方式(Unicode编码了所有语言)
要想javac正常的带中文字符的文件需要执行下面的命令：
  javac -encoding utf-8 文件名（因为实际开发中的Unicode编码为utf-8）
  javac 文件名(源文件纯英文时使用)


class可以有多个class，public class不是必须的
一个class就会生成一个xxx.class的字节码文件
public class和class的区别：
     1：public class中的类必须和文件名字一致
        即一个java源文件当中定义公开的类的话，只能有一个，并且该类名称必须和Java源文件名称一致
     2.每一个class当中都可以编写main方法，都可以设定程序的入口
     3.没有入口（主方法public static void main(string[] args)）无法使用java xxx.class指令


标识符：
    可标识的东西：类名、方法名、变量名、接口名、常量名。。。。。。
    命名规则：
        1.只能由数字、字母、下划线_、$组成，不能含有其他特殊符号
        2.不能以数字开头
        3.区分大小写
        4.不能使用关键字做标识符
        5.没有长度限制（但不要太长）
    命名规范（不强制，不会报错）：
        1.见名知义（如：UserLogin，Password等等）
        2.最好驼峰式命名（SystemService，PasswordLogin等等）
    类名、接口名：首字母大写，后面每个单词首字母大写
    变量名、方法名：首字母小写，后面的每个单词首字母大写
    常量名：全部大写
    不合法标识符举例：123、123sb、傻哔、Hello-World、Hello World、HelloWorld#


关键字
    关键字举例：
	    public
	    class
	    static
	    void
	    if
	    for
	    while
	    do
	    default
	    byte
	    short
	    int
	    long
	    float
	    double
	    boolean
	    char
	    private
	    protected
	    switch
	    true
	    false
	    throw
	    try
	    catch
        ......


字面值（相当于C语言中的常量<Java中常量有新的定义>）
    举例：
        1、100、1.78、"我是傻逼"、"abc"、'a'、true、false......
    字面值就是数据
    字面值是Java源程序的组成部分之一
    数据根据现实生活的应用被划分为多个种类
        整数型：10、100
        浮点型：3.14、1.78
        布尔型：true、false
        字符串型："abc"、"我是傻逼"
        字符型：'a'、'我'
    字符串型必须使用""，字符型必须使用''(皆是半角)
    ''中只能放字符(只能单个的字)

变量
    定义：本质上是内存中的一块儿空间，这个空间有数据类型、名称和字面值
          变量包含三部分：数据类型、名称、字面值
          变量是内存中存储数据的最基本的单元
    数据类型：不同的数据有不同类型，不同的数据类型底层会分配大小不同的空间。
              数据类型是指导程序在运行阶段分配多大的内存空间。
    变量要求：变量中存储的具体的数据必须要和变量的数据类型一致，不一致会报错。
    声明变量的语法：
        数据类型：整数型int，浮点型float等等
        变量名：只要是合法的标识符就行。
        举例：int a;
              int age;
    声明变量后的赋值：
        格式：变量名 = 字面值;
        要求：字面值的数据类型必须和变量的数据类型一致；
              = 是赋值运算符(先运算=右边的表达式，执行结束后的结果赋值给左边的变量)
    声明和赋值可以放到一起完成。(例：int a = 10)
    变量赋值后可重新赋值，即变量的值可以变化的，通过变量的概念使得内存空间得到了重复的利用
    访问变量的方式(get)：
        1：读取变量中保存的具体数据
        2：修改变量中保存的具体数据
        PS:变量的重新赋值不是在内存中直接修改，而是在内存中重新开辟了一个值，旧的字面值所占用的内存空间作废
    变量在一行上可以声明多个(int a,b,c;)
    变量必须先声明再赋值，才能访问(变量未赋值时不会开辟内存空间，即变量没有初始化，没有初始化不可访问。)
    注：上面所说的是局部变量，成员变量未赋值会默认赋值为0
    同一“作用域”中变量名不能重名
    变量作用域域：变量的有效范围(记忆小技巧：“出了大括号就不认识”)
                  变量的作用域全看变量所处的地方，可以是类体，可以是方法体
                  循环体中的变量的作用域只在其循环体中，循环结束即被释放内存
                  不同的作用域变量名可以重名
    变量的字面值的输出遵循就近原则（先内后外，先上后下）
    类体中除了声明变量之外不可直接在方法体外编写Java语句
    变量的分类：
        1.根据变量声明的位置来分类：
            局部变量：在方法体内声明
            成员变量：再方法体外声明（在类体内）


数据类型
    不同类型的数据类型占用空间大小不同
    数据类型的作用是知道JVM在运行程序时该该数据分配相对应的不同的内存空间
    Java数据类型包括“基本数据类型”和“引用数据类型”
    基本数据类型：
        基本数据类型包括四大类八小种
        第一类：整数型（byte、short、int、long）
        第二类：浮点型（float、double）
        第三类：布尔型（boolean）
        第四类：字符型（char）
    引用数据类型：（类、接口、数组......）
    字符串不属于基本数据类型，属于引用数据类型，字符属于基本数据类型
    各基本数据类型占用的空间大小：
        基本数据类型      占用空间大小(单位：字节)     取值范围
        ------------------------------------------------------------
        byte              1                            -128~127
        short             2                            -32768~32767
        int               4                            -2147483648~2147483647
        long              8                            -9223372036854774808~9223372036854774807
        float             4                            3.402823e+38 ~ 1.401298e-45
        double            8                            1.797693e+308~ 4.9000000e-324
        boolean           1                            true/false
        char              2                            
    计算机在任何情况下都只认识二进制
    Java中的数字有正负之分，所以数字的二进制中有一个二进制位称作“符号位”
    “符号位”在所有二进制最左边，0表示正数，1表示负数(例：+8<十进制>=01000<二进制>，-8<十进制>=01000<二进制>)
    例：byte类型最大值：01111111<二进制>（即127<十进制>）
                最小值：11111111<二进制>（即-128<十进制>）
        计算最大值和最小值方法
            例：byte最大值：11111111 - 1=01111111（127）
                short最大值：11111111 11111111 - 1 = 01111111 11111111（32767）
    ASCII字符编码：例：'a'--> 97 [01100001]
                   'a'--(按照ASCII解码)--> 01100001
                   0100001--(按照ASCII编码)-->'a'
                   编码和解码的时候采用同一套字典/对照表，不会出现乱码
                   当解码和编码的时候采用的不是同一套字典/对照表，会出现乱码
    字符型char和短整型short虽然都是2字节，但是short的取值范围是-32768~32767，char取值范围是0~65535
    char没有负数，short其实和char能用相同数量的值
    每一种成员变量的数据类型都会有固定的默认值
    八种数据类型的默认值(即未赋值时系统自动给出的值)：
        数据类型                        默认值
        -------------------------------------------------
        byte、short、int、long          0[long初始值为0L]
        float、double                   0.0
        boolean                         false[在C语言中，true是1，false是0]
        char                            \u0000
    八种数据类型的默认值是一切向0看齐

    char类型：
        由于一个中文字符正好占两个字节，所以Java的char类型正好可以储存一个中文字符
        char的格式用''表示
        转义字符：
            \在Java中具有转义功能，与后面的一个字符合并为一个字符，也可以将特殊符号转义为普通符号
            \n表示一个字符，作用为换行，属于char类型
            \t表示一个字符，作用为制表，属于char类型（作用和tab键相同）
        JDK中的native2ascii.exe可以将文字转换为Unicode编码格式(可用于查阅中文字符的对应Unicode码)
        根据上面的查阅功能可以直接用Unicode码作为字面值（使用时需要用转义字符\）
    System.out.println表示输出并换行，System.out.print表示输出不换行

    整数型：
        Java中的整数类型默认使用int类型来处理，例：long a = 123，123其实为int型
        要让整数型当作long类型来处理的话，需要在整数型字面值后面添加l/L，建议用大写的L
        Java整数型字面值有三种表示方式：
            十进制：是一种缺省默认的方式
            八进制：在编写八进制整数型字面值的时候需要以0开始
            十六进制：在编写十六进制整数型字面值的时候需要以0x开始
        小容量整数类型可以自动转换为大容量整数类型，称为自动类型转换机制（如int转换为long）
        大容量整数类型不可以自动转换为小容量整数类型，需要进行强制转换（如int转换为short）
        强制转换需要添加“强制类型转换符”，但运行阶段会损失精度，损失精度后可能会损失严重
        “强制类型转换符”需要谨慎使用，使用方法：
            例:long x = 100L;
               int y = (int)x;
        强制转换原理：（以100从long型转换为int型为例）
            转换前：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
            转换后：                                    00000000 00000000 00000000 01100100
            计算机存储数据都是采用的补码形式，大的字面值如2147483648时会出现巨大的精度缺失
        Java编程时会对byte有所优待，byte形式直接赋值不超出取值不会报错，强制转换同样会损失精度
        short同上
        补码：正数的补码和原码相同，负数的补码是对应的正数的原码取反再加1
            例：-128
                原码：1 10000000 [-128的原码][第一个为符号位，负数是1]
                反码：1 01111111 [取反][符号位不变]
                补码：1 10000000 [加一]
                128
                原码：0 10000000 [128的原码][第一个为符号位，正数是0]
                反码：0 01111111 [取反]
                补码：0 10000000 [加一]
                所以正数的补码和其原码相同
                .:.所以反过来讲，强制用byte型转换int型的128，由于缺少前面三字节，加上最后一字节得开头是1，系统就会认为是负数，但由于是正数，系统还是按照了正数的方法进行了补码，从而输出为了错误的值-128，其他同理

    浮点数：
        float为单精度，double为双精度
        Java中的浮点型字面值默认当作double类型来处理
        要想以float类型来处理，需要在字面值后添加f/F

    布尔型：
        Java不像C语言可以用0和1表示假和真，布尔型只有true和false
        布尔型经常使用在逻辑运算和条件控制语句中
        计算机底层中true为1，false为0

    基本的数据类型的互相转换：
        转换规则
            1：八种数据类型除布尔类型之外都可互相转换
            2：小容量向大容量转换，称为自动类型转换（容量小到大排序：byte<short<int<long<float<double）
                                                                              char <[与short容量相同]
                                            注：任何浮点类型不管占用多少字节都比整数型容量大
                                                char和short可表示的种类数量相同，但char可以取更大的正整数
            3：大容量转换为小容量可以进行强制类型转换，需要添加强制转换符，可能会损失精度，谨慎使用
            4：当整数字面值没有超过byte，short，char的取值范围时，可以直接赋值给着三种数据类型的变量
            5：byte、short、char混合运算的时候，先各自转换成int类型再做运算
            6：多种数据类型混合运算，先转换成容量最大的那个数据类型再进行运算


运算符
    种类：
        算术运算符
            +  求和
            -  相减
            *  乘积
            /  商
            %  求余数【取模】

            ++ 自加1
            -- 自减1
        关系运算符
            >  大于
            >= 大于等于
            <  小于
            <= 小于等于
            == 等于
            != 不等于
        逻辑运算符
            &  逻辑与[真&真=真；真|假=假；假|假=假]
            |  逻辑或[真|真=真；真|假=真；假|假=假]
            ！ 逻辑非[!真=假；  !假=真]
            ^  逻辑异或[只要两边不一样就是真]

            && 短路与
            || 短路或
        字符串连接运算符
            +
        赋值运算符[赋值规则：右赋给左](除基础运算符=外其余都是扩展运算符)
            =   赋值

            +=  追加
            -=  追减
            *=
            /=
            %=
        三元运算符/条件运算符
            布尔表达式?表达式1:表达式2

    一个表达式中有多个运算符，运算符有优先级，不确定的加小括号，使优先级得到提高
    自加1和自减1的运用
        ++出现在变量后规则：先做赋值运算，再对变量中保存的值进行自加
        ++出现在变量前规则：先进行自加1，再赋值

    关系运算符的运算结果一定是布尔类型：true/false

    逻辑运算符要求两边的算子都是布尔类型，并且最终运算结果也是布尔类型
    逻辑与&与短路与&&的区别
        &无论第一个表达式有没有决定最终结果都会执行第二个表达式
        &&在第一个表达式已经决定最终结果时不再执行第二个表达式
        &&的现象被称为短路现象（短路或亦相同）
        所以&&更加常用，除非有特殊要求两边表达式都需要执行会不得不使用&

    赋值运算符
        编译器只检查语法，不运行程序
        扩展赋值运算符不改变运算结果类型，所以不需要再添加强制转换类型符

    “+”运算符
        作用：1.加法运算，求和。2.字符串的连接运算
        规则：“+”两边都是数字时一定是加法运算，只要有一边数据是字符串，一定会进行字符串连接运算并且输出字符串
        一个表达式中可以出现多个+，在没有()的前提下，遵循自左向右的顺序运算
        附：字符串的引用数据类型：String[S要大写，且String无法兼容基本数据类型]

    三元运算符/条件运算符/三目运算符
        语法规则：
            布尔表达式?表达式1:表达式2
        执行原理：
            当布尔表达式的结果为true 时，选择表达式1作为整个表达式的执行结果；
            当布尔表达式的结果为false时，选择表达式2作为整个表达式的执行结果。
        如果是定义中，那表达式1和2数据类型必须兼容前面的定义，比如char a = boolean？"a":'b'就是错误的
        如果直接再输出语句中写入三元表达式，则可以混用字符和字符串，
            比如：System.out.println(boolean?"a":'b');是完全可以运行的。
        小贴士：三目运算符也是可以嵌套的，两层嵌套的格式为：
            布尔表达式1?(布尔表达式2?表达式1:表达式2):表达式3【括号也可以不要】
            【本质上和if语句嵌套差不多，先判断第一个布尔表达式，若为假，执行表达式3，若为真，执行括号内的三目运算符】



控制语句：
    所有的控制语句都是可以合理嵌套的
    种类：
        控制选择结构：
            if、if else
            switch
        控制循环结构：
            for
            while
            do while
        改变控制语序顺序：
            break
            continue
    if语句：（分支语句/条件控制语句）
        重点说明：对于Java中的if语句来说，之后要有一个分支执行，整个if语句全部结束
        语法结构：(四种编写方式)[这些if语句()中的布尔表达式都必须确定true/false]
            1.if(布尔表达式){
                  语句;
                  语句;
                  ......
              }
            2.if(布尔表达式){
                  语句;
                  语句;
                ......
              }else{
                  语句;
                  语句;
                  ......
              }
            3.if(布尔表达式){
                  语句;
                  语句;
                  ......
              }else if(布尔表达式){
                  语句;
                  语句;
                  ......
              }else if(布尔表达式){
                  语句;
                  语句;
                  ......
              }......
            4.if(布尔表达式){
                  语句;
                  语句;
                  ......
              }else if(布尔表达式){
                  语句;
                  语句;
                  ......
              }else if(布尔表达式){
                  语句;
                  语句;
                  ......
              }else{
                  语句;
                  语句;
                  ......
              }
            第二种和第四种都带有else分支，会保证100%有分支执行
        所有的控制语句都是可以合理嵌套的
            示例：
            if(){
                if(){
                    if(){

                    }
                }
            }else(){
                if(){
                    if(){

                    }
                }
            }
            注意：嵌套使用的时候，代码格式要保证完美【合理缩进】
        if语句的分支中只有一条Java语句的时候{}可以不写(但不推荐使用[格式不美观])
            示例：
            if(){
                语句;
            }
            相当于
            if() 语句；
    附：Test5.java文件中有关于如何用键盘输入字符的代码，如果忘了可以从那里找到。

    swith语句：
        switch语句属于选择结构，也是分支语句
        语法结构：
            switch(int或String类型的字面值变量){
                case int或String的字面值或变量:
                    Java语句;
                    ...
                    break;//缺少此语句会发生case穿透现象 
                case int或String的字面值或变量:
                    Java语句;
                    ...
                    break;
                case int或String的字面值或变量:
                    Java语句;
                    ...
                    break;
                ......
                default:
                    Java语句;
                    ...  
            }
            //注：case穿透会导致下一分支的case不进行匹配，直接执行下一分支的语句
        case与switch匹配成功后，若有break语句，整个switch语句终止；
        case与switch匹配成功后，若没有break语句，会直接进入下一分支执行（且不与其case匹配）
        所有case与switch都不匹配的话，若有default语句，会执行default分支中的语句
        switch的()中的数据只能是int或String类型的语句//JDK6之前只能是int
        switch的()中的数据为byte，short，char时会自动转换为int类型（字符转换原理有讲）
            根据上一个原理可以使用char数据类型来编写
        case可以合并，示例：
            switch(int或String){
                case int或String: case int或String: case int或String:
                System.out.println();//只要出现上面的case任意一种匹配，这一语句都会执行
            }

    循环结构：
        把需要反复执行的代码片段放到“循环体”，再联合“计数器”来共同控制
        循环结构包括for循环、while循环、do、do...while循环三个循环

    for循环：
        语法结构：
            for(初始表达式;布尔表达式;更新表达式){
                //放置需要重复执行的代码片段【即：循环体】
            }
        执行过程/执行原理：
            1.初始化表达式、布尔表达式、更新表达式都不是必须的【但分号不能缺少】
            2.初始化表达式最先执行，并且在整个for循环中只执行一次
            3.for的执行过程：
                *先执行初始化表达式，并且该表达式只执行一次
                *判断布尔表达式的结果是true还是false
                    -若为true：执行循环体
                    -若为false：循环结束
                *执行更新表达式
                *判断布尔表达式的结果是true还是false
                    -若为true：*执行循环体
                               *执行更新表达式
                               *判断布尔表达式的结果是true还是false
                                   -若为true：*执行循环体
                                              *执行更新表达式
                                               ......
                                  -若为false：循环体结束
                    -若为false：循环结束
            简化for循环过程的理解(先执行初始表达式，然后布尔表达式->循环体->更新表达式逆时针循环，直到结束)
                图解：初始表达式->布尔表达式<-更新表达式
                                      |         ^
                                      |        /
                                      循环体--/
        使用循环语句可以使代码量变少，是颇为重要的加大效率的方法
        若是在外部定义的变量，那for循环结束后该变量会更新为for循环最后更新的变量(即看最后一次更新表达式)
            示例：int a = 0;for(;a<10;i++){};再输出a1;其中a在循环体内经历了0-9，外部再输出的是10。
        for循环的循环体若是只是单一语句，可以不加大括号。
        即不加大括号{}时for循环只影响下面最近的一条语句
        循环体中可以编写其他控制语句

    while循环：
        语法结构：
            while(布尔表达式){
                循环体;
            }
        循环原理：
            *先判断布尔表达式的结果
                若为true：
                    -执行循环体
                    *判断布尔表达式的结果
                        若为true：
                            -执行循环体
                            *判断布尔表达式的结果
                                若为true：
                                    -执行循环体
                                     ......
                                若为false：循环结束
                        若为false：循环结束
                若为false：循环结束
        循环次数：0-n次【while循环的循环体可能一次都不执行】

    do...while循环：
        语法结构：
            do{
                循环体;
            }while(布尔表达式);
        执行原理：
            *先执行循环体
            *判断布尔表达式true还是false
                如果为true：
                    -执行循环体
                    *判断布尔表达式true还是false
                        如果为true：
                            -执行循环体
                             ......
                        如果为false：循环结束
                如果为false：循环结束
        执行次数：1-n次，do...while循环体至少会执行1次
        do...while循环体记住不要忘记写“;”

    break语句：
        break是关键字，译为“中断”，break;为一个完整的Java语句
        break语句在switch语句中用来终止switch分支语句的执行
        break同样可以使用在循环语句中，用来终止循环的执行，从而提高程序的运行效率(黄金体验)
        在默认情况下，break语句中断的是离它最近的循环
        可以使用命名的方法直接将break强制作用在某个循环上，这样就影响到了那个循环[格式：break 循环名称;]

    continue语句：
        continue是关键字，译为“go on”，即“下一个”，continue;为一个完整的Java语句
        continue语句主要是出现在循环语句中用来控制循环的执行
        continue的控制原理：终止当前这一次的循环，直接跳过这个循环进入下一次循环(绯红之王)
        可以使用命名的方法直接将continue强制作用在某个循环上，这样就影响到了那个循环[格式：continue 循环名称;]



方法
    方法的本质：
        就是一个代码片段，并且这个代码片段可以被重复的使用并完成特定的功能
        注：方法在C语言中叫做函数
    方法只定义在类体当中，一个类可以定义多个方法，且没有先后顺序
    方法体中不能再定义方法，只能再类体中，方法体中的代码是有顺序的
    
    方法的机制：
        某个功能代码只需要写一遍;要使用这个代码，只需要给这个功能传递具体的数据
        这个过程被称为调用(invoke)
    
    基础语法：
        [修饰符列表] 返回值类型 方法名(形式参数列表){
            方法体;
        }

    解释说明：
        关于修饰符列表：
            可选项，不是必须的，目前可以统一写成public static【以后说】
            当修饰符列表中有static关键字时，如何调用该方法？
                -类名.方法(实际参数列表);【意为什么类的什么方法，用什么参数】
        关于返回值类型：
            一个方法是用来完成某个特定功能的，这个功能结束之后大多数需要返回最终执行结果
            最终结果可能时一个具体存在的数据，只要是数据就一定有类型
            这个具体存在的数据就是返回值
            返回值的类型：
                Java中的任意一种类型都可以作为返回值类型，包括基本数据类型和引用数据类型
            不是所有的方法都需要返回值，当不需要返回值需要写上void关键字
            若返回值不是void，则表示这个方法执行结束后必须返回一个具体的数值，否则编译器报错
            返回值的方法：
                return 值;
                要求：1.返回值的数据类型必须和方法的返回值类型一致，否则编译器报错
                      2.返回值是void时不能写return 值;语句，但可以编写return;这个语句
            PS：只要return关键字所在语句执行,return语句所在的方法结束(而非JVM结束)
        关于方法名：
            只要是合法的标识符就行;最好见名知意;方法名最好是动词;方法名最好采用驼峰式命名

    形式参数列表：(简称形参)
        形参是局部变量
        形参的个数是0-n个
        多个形参之间用“,”隔开
        形参中起决定性作用的是形参的数据类型，形参的名字只是局部变量的名字，是合法标识符就行
        方法再调用的时候，实际给这个方法传递的真实数据被称为：实际参数(实参)

    方法调用：
        方法只定义不去调用是不会执行的，旨在调用时才会执行
        语法规则：[修饰符列表中有static]
            类名.方法名(实参);//表示调用某个类的某个方法，传递这样的实参
        调用时必须注意形参和返回值的数据类型
        调用时调用的方法的参数命名和主方法的参数命名不冲突(即形参是局部变量)
        调用方法时的实参一定要和被调用的形参的类型和数目相同
        带有static关键字的方法在被调用时可以省略类名(仅限于在同一类中)
        一个方法有返回值时，对于这个返回值接收和不接收都可(大多数情况下都接收)

    return语句：
        带有return关键字的Java语句只要执行，所在的方法执行结束[注意是直接终止的方法]
        同一作用域中return之无法再写语句，因为永远不会执行
        在返回值为void时不可以在空方法内直接使用“return [返回值];”语句(因为无返回值)，但可以直接使用return;

    方法在执行过程中的内存分配：
        方法只定义不调用是不会执行的，也不会给该方法分配内存空间，只有调用方法时才会调用所属内存空间
        在JVM内存划分上有三块主要的内存空间：
            方法区内存：class字节码片段
            堆内存：new[实例化]的对象
            栈内存：方法的代码片段
        数据结构反应的是数据的存储形态
        常见的数据结构：(数组，队列，栈，链表，二叉树/散列表......)
        栈数据结构：(stack)，是一种数据结构[≠数据类型]//数据结构不局限于Java甚至是编程[很重要]
        代码片段：
            方法代码片段存储在方法区内存当中，属于.class字节码文件的一部分，
                当.class文件在加载时，将方法片段放到了方法区中，所以三大内存空间中方法区最先有数据
            代码片段虽然在方法区内存中只有一份，但可以被重复调用，
                每一次调用该方法时，需要给该方法分配独立的活动场所，在栈内存中分配，即栈分配方法的运行的空间
        方法在调用的瞬间，会给该方法分配内存空间，在栈中发生压栈动作，
        方法执行结束后，会给该方法分配的内存空间全部释放，此时发生弹栈动作
            压栈：给方法分配内存
            弹栈：释放该方法的内存空间
        局部变量在方法体中声明，局部变量运行阶段内存在栈中分配

    PS：类体中不可以写除声明变量之外的Java语句
    参数的传递中传递的是变量中保存的值
    
    重载机制(overload)：
        有些方法虽然功能不同，但是功能是相似的，如果不适用重载，调用方法的时候不方便，也不利于记忆
        重载的目的是调用类似方法时就像是调用一个方法一样，不需要再记忆多余的方法
        （不是所有的语言都有重载机制，JavaScript，C等等都没有重载的概念）
        方法重载时区分方法不再靠方法名而是靠数据类型
        没有相似处的方法最好不要使用重载，否则会发生混乱
        即满足重载方法的条件：
            -方法名相同
            -参数列表不同：
                -数量不同
                -顺序不同
                -类型不同
        方法重载和返回值类型无关

    方法递归：
        定义：方法自身调用自身
        递归非常耗栈内存，不需要用尽量就不用
        递归若是没有停止条件会发生栈内存溢出，并且错误无法挽回，最终JVM停止工作
        栈内存溢出时JVM会提示：java.lang.StackOverFlowError
        递归即使有了结束条件且条件时正确的，也有可能发生栈内存溢出，因为递归的太深了


面向对象：(C语言：纯面向过程;C++：半面向对象;Java：纯面向对象)[盖饭/面向对象 和 蛋炒饭/面向过程]
    现在出现的一些新的语言多数都是面向对象的，因为更符合人的思维方式
    现在多数语言追求“低耦合度”“高扩展性”[耦合度的强弱表示对象联系是否紧密]
    面向对象和面向过程的区别：
        面向过程：主要关注的点是实现的具体过程和因果关系
            优点：业务逻辑简单的程序可以达到快速开发节省成本的效果
            缺点：很难解决复杂的业务逻辑，
                  另外面向过程会导致软件元素之间的“耦合度”非常高，只要其中一处出现问题，整个系统都会受到影响
                  扩展性差
                  由于没有[独立体]的概念，所以无法组件复用
        面向对象：主要关注的点是对象[独立体]能完成哪些功能，各个对象被联系到一起成为一个系统
            优点：耦合度低，扩展性强，更容易解决复杂的业务逻辑，组件复用性强
            缺点：前期投入成本较高，需要进行独立体的抽取和大量的系统设计
    面向对象的三大特征：(所有面向对象的语言都具有这三大特征)
        封装
        继承
        多态
    采用面向对象的方式开发软件时的声明周期(专业术语要记住)：
        面向对象的分析：OOA
        面向对象的设计：OOD
        面向对象的编程：OOP
    类和对象的概念：
        类：类在现实生活中是不存在的，是一个模板，代表了一类事物
            在显示世界中，对象之间具有共同特征，进行抽象总结出一个模板，这个模板即为类
        对象：对象是实际存在的个体，显示世界实际存在
        类到对象的过程被称作“实例化”
        对象到类的过程被称作“抽象”
        对象又被称作“实例”[instance]
        一个类主要描述的信息：状态+动作
            状态：一个类的属性
            动作：一个类的方法
        PS：状态和动作当具体到某一个对象上后，发现最终的结果可能不一样
            对象和对象之间有共同特征，但具体到对象后有数据的差异

    类的定义：
        语法结构：
            [修饰符列表] class 类名{}
        类的属性通常采用变量的方式去定义，这种方法体之外的变量被称作“成员变量”
        成员变量没有赋值，系统默认赋值：一切像0看齐
        引用数据类型中的数据类型本质上是一个类的类名
        即Java语言中的所有class都属于引用数据类型
            例：String a = "abcd";[String.java在src.jar中可以找到]
        成员变量不能直接通过类访问，所以成员变量有被称作“实例变量”
        对象又被称作实例，所以实例变量又被称作“对象变量”【对象级别的变量】
        当不创建对象时，实例变量的内存空间时不存在的，只有创建了对象，这个实例变量的内存空间才会创建
        通过一个类可以实例化n个对象
            语法：
                new 类名();
        new是Java的运算符，作用是创建对象，在JVM堆内存中开辟新的内存空间
        堆内存：new的对象在堆内存中
        引用：引用是一个变量，只不过这个变量中保存了另一个Java对象的内存地址
        Java语言中程序员不能直接操作堆内存，Java中没有指针概念[指针可以直接操纵]
        Java程序员只能通过“引用”去访问堆内存当中对象内部的实例变量
        访问实例变量的语法格式：
            语法：
                读取数据：引用.变量名;
                修改数据：引用.变量名 = 值;
        引用也可以理解为用变量指向了一个类的地址，通过新变量进行访问
        变量：
            局部变量：[方法体内声明]
            成员变量：[方法体外声明]
                实例变量[没有修饰符static][实例变量只有创建对象才能被访问]
                静态变量[有修饰符static]
        静态变量存储在方法区内存中
        三大内存中变化最频繁的是栈内存，最先有数据的是方法区内存，垃圾回收器主要针对的是堆内存
        垃圾回收机制(GC机制)：
            当堆内存当中的Java对象成为垃圾数据时，会被垃圾回收器回收
            Java对象成为垃圾数据的标志：没有更多的引用指向它
            Java垃圾数据回收后的效果：此对象无法被访问，因为访问对象只能通过引用的方式访问
        “实例相关的数据表示”：这个数据访问的时候必须有对象的参与
        引用对象实质上是通过引用保存了对象的内存地址

    面向对象的封装性：
        封装的优点：
            封装之后，对于事物来说看不到事物复杂的那一面，只能看到该事物的简单的那一面
            复杂的封装对外提供了一个简单的操作入口[如：照相机]
            封装之后才会形成真正的“对象”，真正的“独立体”
            封装就意味着以后的程序可以重复的使用，并且这个事物适应性强，任何场合都能使用
            封装之后对于事物本身提供了安全性
        封装的步骤：
            1.所有属性私有化，使用private关键字进行修饰，修饰的所有数据只能在本类中访问
            2.对外提供简单的访问入口
                  对外提供两个公开的方法，分别是set方法和get方法，所用是修改和读取
                  set方法的命名规范：
                      public 返回值 set+属性名字(形参){}
                  get方法的命名规范：
                      public 返回值 get+属性名字(形参){}
        封装的注意点：
            set和get的方法没有static关键字
            没有static关键字修饰的方法如何调用：
                引用.方法名(实参);
            (回顾：有static关键字修饰的方法如何调用：类名.方法名(实参);)

    构造方法：(构造函数/构造器)：
        语法结构：
            [修饰符列表] 构造方法名 (形参){
                构造方法体;
            }//和普通方法不同的是构造方法没有返回值类型
        对于构造方法来说返回值类型不需要指定，并且也不能写void，否则就变成了普通方法
        对于构造方法来说，构造方法的方法名必须和类名保持一致
        构造方法的作用：
            通过构造方法的调用，可以创建对象
        构造方法的调用：
            new 构造方法名(实参);
            (回顾：普通方法的调用：类名.方法名(实参)/引用.方法名(实参)[区别于有无static])
        每一个构造方法实际上执行结束后都有返回值，但不需要return语句，且返回值类型为构造方法所在的类型
            即返回值类型与类名保持一致
        当一个类没有定义构造方法的话，系统会默认给该类提供一个无参数的构造方法，
            这个构造方法被称作为“缺省构造器”
        当一个类手动定义了一个构造方法时，系统就不会为此类提供“缺省构造器”
        建议开发中手动为当前类提供无参构造方法
        构造方法也支持重载机制，所以可在一个类中也可以定义多个构造方法
        PS：eclipse按住Ctrl键鼠标移向构造方法可以查看构造方法所在地
            或者使用Ctrl+o使用关键词快速查找

    参数的传递：
        例：int a = 10 ;
            int b = a  ;//此时a传递给b，实际上只是将a的10传递给b，b实际上新开辟了一个内存空间

    this关键字：
        this是一个引用，是一个变量，this存储在JVM堆内存相关对象的内部
        this保存对象地址指向自身
        每一个创建的对象都有this关键字
        注：没有static关键字的方法被称作“实例方法”
            没有static关键字的变量被称作“实例变量”
        当一个行为或者动作执行时需要对象参与时一定要定义为“实例方法”
        this无法使用在含static的方法中，因为含有static的方法没有“当前对象”
        一个类中含有多个构造方法并且想直接调用某构造方法时：[举例：]
            public void A(int a){}
            public void A(){
                this(1);//1可以用其他参数代替，这里只是举例
            }//想直接调用A构造方法，但是又不想新建对象(new)造成代码冗余
            注意点：1.使用new A(1);固然也可以调用，但是这样会让堆内存新开辟A()对象的空间
                    2.this();只能出现在构造方法的第一行
        this可以使用的地方：
            1.可以使用在实例方法中，代表当前对象[语法格式：this.对象]
            2.可以使用在构造方法中，代表当前构造方法调用其他的构造方法[语法格式：this(实参);]

        小知识点补充：其实带有static的方法也可以使用引用来调用，但反过来无static方法不能直接调用
                      但实质上static方法引用本身是没有用的，就算将引用设置为空值也不会产生空指针异常
                      建议还是别这样瞎折腾，老老实实用类名.方法();
                      [原理会在static关键字中讲]

    static关键字：
        当一个实例变量创建时想保证为一个固定值，且不想使这个变量在被引用时占用多余空间，便可使用static关键字
            （因为对象在被引用时，有几个引用就会在堆内存生成几个对象的内存）
        所有对象的某个变量一样，这种特征属于类级别的特征，也可以提升为整个模板的特征，和具体的对象无关
            方法：在该变量前添加static关键字修饰，这种称谓“静态变量”
        静态变量：
            静态变量在类记载的时候初始化，不需要创建变量，内存就开辟了[所以可以该变量可以直接被调用]
            静态变量存储在方法区内存中
        成员变量的两种情况：
            实例变量：所有对象都有这个属性，该变量的值会随着对象的变化而变化[对象不同值也会不同]
            静态变量：所有对象都有这个属性，该变量的值在所有对象中是一样的[保持不变]，节省内存
        所有静态的数据都可以使用类名.数据来调用，也可以使用引用，但不建议[原因见this关键字最后]
        可以用static关键字来定义“静态代码块”
            语法格式：
                static{
                    Java语句;
                }
            “静态代码块”在类加载时执行，并且只执行一次
            静态代码块在一个类中可以和编写多个，并且遵循自上而下的顺序依次执行
            静态代码块是Java为程序员准备的一个特殊的时刻，这个特殊时刻被称为“类加载时刻”                若在此刻执行一段特殊的程序，这段程序可以直接放到静态代码块当中
                例：在某个程序启动的那一瞬间完成一个日志记录，那这段日志代码就可以放在静态代码块当中
            通常在静态代码块中完成预备工作，先完成数据的准备工具
                例如：初始化连接池、解析XML配置文件......
        补充说明：【实例代码块】：[实际开发中用的极少]
            语法格式：
                {
                    Java语句;
                }
            实例代码块也可以编写多个，并且也遵循自上而下的顺序执行
            实例代码块在构造方法执行之前执行，构造方法执行一次，实例代码对应执行一次
            实例代码块也是Java为程序员准备的特殊时刻，这个时刻被称作“对象初始化时刻”
        小知识：main方法也是可以重载的[毕竟就是一个普通方法(笑)]
        方法定义为静态的条件：
            方法描述的是动作，当所有的对象执行这个动作的时候，最终产生的影响是一样的，
                那么这个动作语句不在属于某一个对象动作了，可以将这个动作提升为类级别的动作，模板级别的动作
        静态方法中无法直接访问实例变量和实力方法
        大多数方法都定义为实例方法，因为需要对象的参与
            但是“工具类”中的方法都是静态方法，目的是方便编程，方便调用

    继承[extends]：
        继承是面向对象的三大特征之一
        继承基本的基本作用是“代码复用”，
        但继承最重要的作用是：有了继承才有以后方法的覆盖和多态
        语法格式：
            [修饰符] class 类名 extends 父类名{
                属性/方法;
            }
        Java语言当中的继承只支持单继承，一个类不能同时继承很多类，只能继承一个类[C++支持多继承]
        继承的专业术语：
            B类继承A类，其中：
                A类称为：父类、基类、超类、superclass
                B类称为：子类、派生类、subclass
        Java子类继承的父类的数据包括：
            私有的不支持继承
            构造方法不支持继承
            其他数据都可以被继承
        虽然Java语言当中只支持单继承，但一个类可以间接继承其他类，例如：
            C extends B{
            }
            B extends A{
            }
            A extends T{
            }//C直接继承B类，但C间接继承A类和T类
        Java中假设一个类没有显示的继承任何类，该类默认继承JavaSE库中提供的java.lang.Object类
            即JavaSe中所有的类其实最终都间接继承了java.lang.Object类
        静态方法能继承，但只能用静态的方式引用“类名.方法()”，否则会警告，但不会报错

        方法覆盖[override]：
            当父类中的方法语句无法满足当前子类的业务需求时，子类有必要将继承过来的方法重新编写
            重新编写的过程称为“方法重写”/“方法覆盖”
            方法重写的要求：返回值类型相同，方法名相同，形参列表相同;
                            访问权限不能更低，可以更高;
                            抛出异常不能更多，可以更少
            小建议：方法重写时尽量复制粘贴，否则可能发生写错导致没有覆盖成功
            注意：
                私有方法不能继承，所以不能覆盖；
                构造方法不能继承，所以不能覆盖；
                静态方法不存在覆盖[多态中有解释]；
                覆盖只针对方法，不谈属性

    多态：
        多态涉及的概念：
            向上转型(upcasting)[自动类型转换]：子类型转换为父类型
            向下转型(downcasting)[强制类型转换]：父类型转换为子类型[需要加强制转换符]
            注：1.无论是向上转型还是向下转型，两种；类型之间必须要有继承关系，否则无法编译通过
                2.编译时类型转换只看父类的对象，运行时看的却是子类继承的对象[重写的会读取重写后的]
        注[2]的重新解释：
            JVM编译阶段检查的数据类型为父类型，后面引用的方法是父类型具有的则会编译通过，
                这个过程称为静态绑定/编译阶段绑定，只有静态绑定成功之后才有后面的运行
            在JVM运行阶段堆内存实际创建的对象其实是子类的对象，调用的也是子类的方法
                这个过程称作动态绑定/运行阶段绑定
            这其实是由于编译器和运行时的差异，编译只找语法的错误，运行才会开辟内存空间
        这种编译和运行时的不同的绑定的状态，被称作多态语法机制
        向下转型的条件：调用的方法是子类型特有的，在父类型中不存在，必须向下转型
        强制类型转换如果是在非继承关系下，编译会通过，但是运行时会显示异常
        该异常为：java.lang.ClassCastException，意为[类型转换异常]
            解决该异常的方法：[使用instanceof运算符]
                语法格式：
                    (引用 instanceof 数据类型名)
                    以上运算符的执行结果为布尔类型(举例：a instanceof A)
                    当结果为true时： a这个引用指向的对象是一个A类型
                    当结果为false时：a这个引用指向的对象不是一个A类型
            Java规范中要求：在进行对象数据类型强制转换前，先用instanceof运算符进行判断，避免出现上述异常
        多态的实际开发方法：
            宗旨：低耦合度，高扩展性
            创建对象时不要直接面向具体的对象，而是面向抽象编程
            即不要直接使用具体事物的类继承主类，而是尽量使用一个高度概括的抽象类
            例：创建master类和cat类，cat继承master，用Test类实现客户要求，后来客户想要改需求，将cat改为dog
                没有多态的修改方法：将class文件还原为Java文件，修改cat为dog或者添加dog类，修改master类中的关系
                                    [费时费力还容易出错]
                使用多态的修改方法：
                    前提：在master类的cat类的基础上，使用了一个pet类，cat继承pet，而pet继承master
                              方法：直接新建一个dog类，继承pet，在Test中引用master对象和dog对象
                                    让dog对象在master中的pet方法中使用
                                    [便于修改，减少错误率]
                注：master类中要引用pet方法，pet要继承master
            Java开发中要面向抽象对象编程，尽量不要面向具体对象编程
            说白了，最好的工程是几乎不改代码就能达到用户的新要求

    final关键字：
        意为：最终的，不可变的
        final修饰的类无法被继承
        final修饰的方法无法被覆盖/重写
        final修饰的变量一旦被赋值后，无法重新赋值
        final修饰的实例变量必须手动赋值，且赋值后无法再重新赋值
        final修饰的引用一旦指向某个对象后无法再指向其他对象，该对象也无法再被当作垃圾回收
        注：虽然final修饰的引用无法再指向其他对象，但是现在指向的对象的内存是可以被修改的
            [形象化记忆]你不可以换老婆，却可以换老婆的衣服
        小贴士：1.其实Java类库中的String类就是用了final关键字修饰[在java.lang.String类中可看]
                2.以后的学习类库的过程最好包括三个部分：源码[看源码来理解程序]
                                                        字节码[程序开发的过程中使用的部分]
                                                        帮助文档[对源码的解释说明，可以提取出来;对开发也有帮助]
        final修饰的实例变量一般是不可变的，这种变量一般和static联合使用，这种变量被称作“常量”
            常量的定义语法格式：
                public static final 类名 常量名 = 值;
                Java规范中要求所有的常量名全部大写，每个单词之间使用下划线连接

    Java软件包机制[package]：
        目的：方便程序的管理，不同功能的类被分门别类放到不同的软件包当中，易于查找和维护
        包的定义方法：
            再Java文件的第一行[注释不算]编写package语句
            package只能编写一个语句
            语法结构：
                package 包名;
        包的命名规范：
            公司域名倒序 + 项目名 + 模块名 + 功能名;
            采用这种方式重名的几率较低[因为公司的域名在全球具有唯一性]
            包名全部小写
            一个包对应一个目录
        如何手动编译一个创建了包的java文件：[以后可能用不到，因为都在IDE中开发]
            1.可以手动创建包所指定的文件夹，然后放入java文件，编译
              编译时只要输入javac *.java便可将该文件夹下的所有Java文件全部编译[闲得慌也可以一个一个编译]
            2.也可以在某个文件夹下使用javac -d . *.java编译[会自动生成包指定的文件夹]
              注意：(1). *.java，不是.*.java[用Linux的人应该熟悉，.指在当前目录，*.java指当前目录的所有Java文件]
                    (2)使用java指令时要在包的最前面的文件夹外执行class文件，执行时需要写完整的包+类名
                       例：在common文件夹下创建了一个包名为yuqiusanren.a.b.c的A.java文件并编译
                           执行时：确定在common文件夹下而不是在其他文件夹
                                   执行指令：java yuqiusanren.a.b.c.A
                    (3)所有指令出现GBK映射错误都参照我该文档写的前几行的方法
        Java文件若是在同一文件下，可以省略包名直接引用或调用，否则必须写全名
        由于没回写全名太麻烦，所以Java使用了import语句
        import语句语法格式：
            import 类名;
            import 包名.*;//任选其一，*不能表示下级目录，所以不要直接想当然写import *;
        jdk的类库中的java.lang包具有特殊性，不需要import也能直接使用

    访问控制权限：
        访问控制权限用来控制元素的访问范围
        访问控制权限符：
            public              表示公开的，在任何位置都可以访问
            protected           同包或子类下可以访问，其他都不想
            缺省                只能在同包下可以访问
            private             表示私有的，只能在本类中进行访问
        访问控制权限符可以修饰类、变量、方法......
        当某个数据只希望系类引用时，可以使用protected修饰
        修饰符的范围：
            private < 缺省 < protected < public
        类只能采用public和缺省的修饰符进行修饰(内部类除外)


集成开发环境：
    简称IDE
    IDE的作用：
        使软件开发变得更简单、更高效
        省去安装jdk，配置环境变量，手动将Java源文件生成.class字节码文件的过程
        IDE可以在Java源程序编写错误时自动提示
        IDE部分代码可以自动生成，更加效率
    Java的常用IDE：
        eclipse
        myeclipse
        IDEA
        NetBeans
        Jbuilder
        ......
    我使用的是eclipse，创建工作空间后会在该文件夹新建.metadata文件夹，
        删除.metadata后会失去eclipse项目，但不会影响到实际的Java项目
        右上角可以调整布局来应用于不同的Java编程方式
        eclipse快捷键：
            CTRL + d  删除一行
            alt + /   自动补全   PS:输入[sysout]再使用自动补全可以直接输入System.out.println();
                                   输入[main]再自动补全可以输入public static void main(){}
            CTRL + 1 进行纠错   PS:也可以使用光标
            CTRL + shift + R 快速查找文件
            CTRL + shift + T 快速查找类
            CTRL + o  查看当前类的所有方法
            右键选择源码->字段生成构造方法 可以一键生成无参构造方法[即去掉所有选项]和有参构造方法
            邮件选择源码->生成Getter和Setter 可以一键生成封装后的实例变量的getset方法
            在eclipse中使用import时可以这样来做：
                正常的引用对象，此时若是不是同一个包下会报错
                这时按快捷键CTRL + alt + o弹出窗口，既可以选择想要的包的类了
            CTRL + B 在debug模式中在某一段添加断点
