本笔记将默认使用的8086CPU
[小贴士：编程中所有的编号从0开始，在查看汇编寄存器图解时看数据一般从下往上看]
计算机编程中赋值都习惯从右往左赋值
汇编二进制的数值后一般使用B当作后缀，十六进制一般使用H当作后缀[二进制:bin,十六进制:hex]
存储器->CPU
CPU是大脑，存储器是心脏
CPU想要进行数据的读写，必须和外部器件(准确的说法是芯片)进行三类信息的交互：
    储存单元的地址(地址信息)
    器件的选择，读或写命令(控制信息)
    读或写的数据(数据信息)
总线：连接CPU和其他芯片的导线
      物理上：一根根导线的集合
      逻辑上：地址总线
              数据总线
              控制总线
      地址总线：如果有n个地址总线[即这个CPU的总线宽度为n]，那这个CPU最多有2的n次方的内存单元
                例：一个CPU的寻址能力是8KB，那这个CPU地址总线宽度就为13[2^n = 8x1024,n=13]
                    四个CPU地址总线分别有16，20，24，32根，那寻址能力分别为64KB，1MB，16MB，4GB

接口卡：用于连接CPU和外部设备

存储器：
    存储器通过总线将数据传给CPU
    1KB的存储器可以存储1024个存储单元，存储单元的编号从0到1023
    属性上的分类：随机存储器(RAM)[能读能写，但设备放电后数据会遗失]
                  只读存储器(ROM)[只能读取，但数据能永远保存，除非刷掉]
    功能和连接上分类：随机存储器RAM
                      装有BIOS的ROM
                      接口卡上的RAM
    BIOS：一般装载在ROM中
          BIOS是由主板和各类接口卡[如：显卡、网卡等]的自己的软件系统
          可以通过BIOS利用硬件进行最基本的输入输出
          主板和各类接口卡上插有存储相应BIOS的ROM
          (小贴士：一些病毒会直接烧录在BIOS里，这样杀毒软件将无法将其杀掉[因为杀毒软件是在操作系统启动后才会出现])
    这两种存储器在物理上是独立的器件，但是有两点相同：
        都和CPU的总线相连
        CPU对他们进行读和写的时候都通过控制线发出读和写的命令

内存地址空间：
    所有的物理存储器被看作由若干存储单元组成的逻辑存储器
    每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间
    CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据
    [即CPU只能看到内存地址空间而看不到存储器]
    8086PC机的内存地址空间分配：
        00000-9FFFF:主存储器地址空间[RAM]
        A0000-BFFFF:显存地址空间
        C0000-FFFFF:各类ROM地址空间
    所有编程最终运行程序的是CPU，所有的汇编问题必须要从CPU角度思考问题

寄存器(CPU工作原理)：
    一个典型的CPU是由运算器、控制器、寄存器等器件组成，这些器件靠内部总线相连接
    总线的区别：内部总线实现CPU内部各个器件的联系
                外部总线实现CPU和主板其他器件的联系
    8086CPU有14个寄存器：
        AX BX CX DX SI DI SP BP IP CS SS DS ES PSW
        AX BX CX DX通常存放一般性数据，被称为通用寄存器
    8086CPU所有的寄存器都是16位的，可以存放两个字节，
        一个16位寄存器所能存储的数据的最大取值为2^16-1[即FFFFH]
    8088CPU为8086CPU的上一代，8088CPU寄存器为8位，现在基本上所有的CPU都是86的CPU
    为了保证兼容性，8086的这四个通用寄存器每个都可以分为两个独立的8位寄存器使用
    AX可以分为AH和AL[high和low，高位和低位]
        BX CX DX同上
    (以AX为例)若是将8086CPU的寄存器分为两个8位寄存器，则可以将AX分为AH和AL，AH里面可都用0代替，只使用AL，亦可相反
        BX CX DX同理

    字在寄存器中的存储
        一个字可以存放在一个16位寄存器中，这个字的高位字节和低位字节自然存储在该寄存器的高8位寄存器和低8位寄存器中
        一个字占两个字节
        习惯上编程中会使用16进制来表示一个数字，
            一个16位的寄存器可以拆分位4段，每段用16进制表示该4位数，合起来便是该数字的16进制数[可用于进行二进制和十六进制的快速换算]
                例：0100 1110 0010 0000这四个二进制数的十六进制数分别是4 E 2 0 ，这个整体的二进制数的十六进制也是4E20
            16进制数中每两位代表一个8进制
            二进制转换16进制的思想也可用于八进制与二进制的转换[只要每隔三位计算一下这三位的八进制数然后拼起来就好了]

    汇编指令：(汇编不强制规定大小写)
        MOV AX,8  将8送入AX                            相当于高级语言中的 AX = 8
        MOV AH,8  将8送入AH                            相当于高级语言中的 AH = 8
        MOV AX,BX 将寄存器中BX的数据送入寄存器AX       相当于高级语言中的 AX = BX
        ADD AX,8  将寄存器AX中的数值加上8              相当于高级语言中的 AX = AX + 8
        ADD AX,BX 将AX与BX中的内容相加，结果存放到AX中 相当于高级语言中的 AX = AX + BX
        当处出现数据溢出后超出部分也不会直接在该寄存器中出现，但是CPU是不会丢弃该进位值，而是放在了另一个地方
        若MOV AL,31H ，则AX的值为0031H ; 若MOV AH,31H ，则AX的值为3100H
        若MOV AL,FFH 并ADD AL,02H ，那AX的结果是无法为0101H的，而是0001H(即AH和AL某方面来说是两个独立的寄存器)

    物理地址：
        CPU访问内存单元时，要给出内存单元的地址，所有的内存单元构成的存储空间是一个一维的线性空间
        这种唯一的地址被称为物理地址

    16位CPU的特征：
        运算器一次性最多可以处理16位的数据
        寄存器最大宽度位16位
        寄存器和运算器之间的通路是16位

    8086CPU给出物理地址的方法：
        8086外部有20位地址总线，可传送20位地址，寻址能力为1M
        8086内部为16位结构，只能传送16位的地址，表现出的寻址能力只有64K
        所以8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址

        8086CPU相关部件的逻辑结构图解：

                        ==>段地址(16位) ==|
                        |                 |
            其他部件 ==>|                 |==>地址加法器
                        |                 |       ||
                        ==>偏移地址(16位)=|       ||
                                                  ||
                                                  ||       ==>物理地址(20位)=|
                                                  ||       |                 |
                                                  \/       |                 |
                                           输入输出控制电路|=>数据总线=======|===>内存
                                                           |                 |
                                                           |                 |
                                                           ==>控制总线=======|

        地址加法器工作原理：[对于上述CPU而言]
            物理地址 = 段地址 x 16 + 偏移地址 [使用的都为16进制][x16其实就是将该16进制数向左移一位(或者说是二进制左移4位)]
            段地址和偏移地址相对于物理地址不是唯一的，有多种组合方法
                如21F60H的物理地址可以分为2000H的段地址+1F60H的偏移地址，也可以分为2100H的段地址+0F60的偏移地址
                    20000   21000
                    01F60   00F60
                    21F60   21F60
            所以物理地址有多种组合方法，如何组合两个地址形成物理地址与CPU相关
            补充：一个数据的二进制左移1位，相当于该数据乘以2
                  因此一个数据的二进制左移n位，相当于该数据乘以2的n次方
                  因此一个数据的十六进制左移一位，相当于该数据乘以16
                  因此可以看出一个数据的X进制左移一位，相当于该数据乘以X
            依照补充中的说明可以看出地址加法器表达式的本质
            本质：物理地址 = 基础地址 + 偏移地址


        段：
            内存中其实没有分段
                使用分段是因为8086CPU采用上面地址加法器的方式给出的内存单元的物理地址，使得我们可以用分段的方式来管理内存
                CPU不存在段的概念，只是程序员强加的定义
                所以即使程序员把某内存单元看作n个段，CPU也只会将整个整体看作一个段
            一个段的起始地址一定是16的倍数[因为段地址x16是16的倍数]
                偏移地址为64位，寻址能力为64K，所以一个段的最大长度为64K
            数据在内存单元中的描述有两种(以21F60H为例)：
                (1)数据存在内存2000:1F60单元中
                (2)数据存在内存的2000段中的1F60H单元中
            所以可根据需要将地址连续、起始地址为16的倍数的一组内存单元定义为一个段

        段寄存器：
            段寄存器就是提供段地址的
            8086CPU有4个段寄存器：
                CS DS SS ES
                当8086CPU要访问地址时，由这四个段寄存器提供内存单元的段地址
                [这四个段地址分别为代码/指令地址，数据地址，堆栈地址，附加地址]
            CS和IP是8086CPU中最关键的寄存器，他们指示了CPU当前要读取指令的地址
                其中CS为代码段寄存器，IP为指令指针寄存器
            8086CPU的工作流程：
                1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器
                2.IP=IP+所读取指令的长度，从而指向下一条指令
                3.执行指令，转到步骤1，重复这个过程
            当8086CPU启动或复位后CS和IP被设置为CS=FFFFH，IP=0000Ｈ
                即在8086CPU刚启动时，CPU从内存FFFF0H单元中读取指令执行
                FFFF0H单元中的指令时8086PC即开机后执行的第一条指令
            在任何时候，CPU将CS，IP中的内容当作指令的段地址和偏移地址，用他们合成指令的物理地址，到内存中读取指令码，执行
            如果说，内存中的一段信息曾被CPU执行过的话，那么，它所在的内存单元必然被CS:IP指向过


机器指令和汇编指令：
    Debug：
        定义：
            Debug是DOS、Windows都提供的实模式(8086方式)程序的调试工具，可以用其查看CPU各种寄存器中的内容、内存的情况和机器码级跟踪程序的运行
        注意：只有Windows32位能兼容16位的Debug，64位Windows10需要使用DOSBox来拟真DOS的Debug环境
        相关指令：(不区分大小写)
            R：查看，改变CPU寄存器的内容
            D：查看内存中的内容
            E：改写内存中的内容
            U：将内存中的机器指令翻译成汇编指令
            T：执行一条机器指令
            A：以汇编的命令格式在内存中写入一条机器指令
        一般来说CPU的生产日期信息在Debug模式中在FFF0H~FFFFFH的某几个单元中，由于信息是在主板的BIOS的ROM中，所以只是只读
            (如果是DOSBox虚拟机默认CPU出产是在1992年)
        一般来说内存中的B8100H开始的单元中的数据是与显存相关，改写数据会出现不同符号

寄存器(内存访问)
    内存中字的存储：
        一个字占两个字节，一个字节占一个内存单元
    DS和[address]：
        DS寄存器通常是用来存放要访问的数据的段地址[DS是数据，CS是代码]
        mov指令的功能：
            将数据直接送入寄存器
            将一个寄存器中的内容送入另一个寄存器中
            将一个内存单元中的内容送入一个寄存器[例:mov bx,1000H mov ds,bx mov al,[0]的效果为将10000H(1000:0)中的数据读到al中]
                                                [反过来如果时mov [0],al则是将al中的数据存入偏移地址为0的数据中]
        第三种mov用法的指令格式：
            mov 寄存器名,内存单元地址(其中[...]表示一个内存单元，如上文[0]中的0表示该数据的偏移地址)
                上面实例中已经将BX中的数据移动到DS中，所以要表示10000H时只需要添加偏移地址0
        8086CPU不支持将数据直接送入段寄存器中，所里理论上不可能发生mov ds,1000H这类的情况，只能通过其他寄存器间接送入数据
        数据-->通用寄存器-->段寄存器
    MOV，ADD，SUB指令：
        MOV：
            MOV 寄存器,数据
            MOV 寄存器,寄存器
            MOV 寄存器,内存单元
            MOV 内存单元,寄存器
            MOV 段寄存器,寄存器[可交换]
        ADD和SUB都有如上的对应指令[但不可以将段寄存器的数据加减入寄存器]
    数据段：
        对于8086机，我们可以根据需要将一组内存单元定义为一个段(代码段或者数据段)

    CPU的堆栈机制：
        栈：
            8086CPU提供入栈和出栈的指令:
                PUSH(入栈)
                POP(出栈)
                例：PUSH AX：将寄存器AX中的数据送入栈中
                    PUSH AX：从栈顶取出数据送入AX中
            8086CPU的入栈和出栈操作都是以字为单位进行的
            8086中由两个寄存器：
                段寄存器SS 存放栈顶的段地址
                寄存器SP   存放栈顶的偏移地址
            任意时刻，SS:SP指向栈顶元素
            PUSH的执行过程：(以PUSH AX为例)
            　　(1)SP = SP - 2(偏移地址减2)
                (2)将AX中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶